---
# Aquarium Dynamic Circadian Lighting Automation  
# The main "brain" of the lighting system - runs every minute to adjust lights
# Combines sun position, weather data, and user preferences for realistic lighting
#
# Features:
# - Solar elevation-based brightness calculation
# - Weather condition modifiers (cloudy, rainy, sunny)
# - Storm lightning effects (when enabled)
# - Comprehensive error handling and fallback logic
# - Detailed logging for debugging and monitoring

alias: "Aquarium Dynamic Circadian Lighting"
description: "Main lighting controller - adjusts aquarium lights every minute based on sun position and weather conditions"
mode: single                           # Prevent overlapping executions

# Trigger Configuration - Execute every minute for smooth transitions
trigger:
  - platform: time_pattern             # Time-based pattern trigger
    minutes: "/1"                      # Every minute (creates smooth lighting transitions)
    id: "circadian_update"             # Unique trigger identifier

# Conditions - Ensure required entities are available before running
condition:
  - condition: template
    value_template: >
      {{
        states('input_number.hygger_white_level') not in ['unknown', 'unavailable'] and
        states('input_number.hygger_red_level') not in ['unknown', 'unavailable'] and
        states('input_number.hygger_green_level') not in ['unknown', 'unavailable'] and
        states('input_number.hygger_blue_level') not in ['unknown', 'unavailable']
      }}

# Action Sequence - Complex lighting calculation and adjustment logic
action:
  # Step 1: Attempt to get fresh weather forecast data
  - service: weather.get_forecasts
    target:
      entity_id: weather.openweathermap # UPDATE: Change to your actual weather entity ID
    data:
      type: hourly                     # Get hourly forecast for detailed conditions
    response_variable: hourly_forecast # Store API response
    continue_on_error: true            # Don't fail if API is down

  # Step 2: Determine weather conditions with robust fallback logic
  - variables:
      # Simplified and more robust weather condition determination
      # Always defaults to 'sunny' to ensure lights work even without weather data
      weather_condition: >
        {% set default_condition = 'sunny' %}
        {% if hourly_forecast is defined and hourly_forecast is mapping and hourly_forecast | length > 0 %}
          {% set first_key = hourly_forecast.keys() | list | first %}
          {% if hourly_forecast[first_key] is defined and hourly_forecast[first_key].get('forecast', []) | length > 0 %}
            {{ hourly_forecast[first_key].forecast[0].get('condition', default_condition) }}
          {% else %}
            {{ default_condition }}
          {% endif %}
        {% elif states('input_text.aquarium_forecast_cache') not in ['unknown', 'unavailable', ''] and states('input_text.aquarium_forecast_cache') | length > 5 %}
          {% set cached = states('input_text.aquarium_forecast_cache') | from_json(default={'condition': default_condition}) %}
          {{ cached.get('condition', default_condition) }}
        {% else %}
          {{ default_condition }}
        {% endif %}
      
      # Sun elevation for lighting calculations with location-aware fallback
      # Optimized for zip code 47124 (Jeffersonville, Indiana: 38.28°N, 85.74°W)
      sun_elevation: >
        {% set elevation = state_attr('sun.sun', 'elevation') %}
        {% if elevation is number %}
          {{ elevation | float(0) }}
        {% else %}
          {% set current_hour = now().hour %}
          {% set current_minute = now().minute %}
          {% set day_of_year = now().timetuple().tm_yday %}
      # Sun elevation for lighting calculations with location-aware fallback
      # Calibrated for zip code 47124 (Jeffersonville, Indiana: 38.28°N, 85.74°W)
      sun_elevation: >
        {% set elevation = state_attr('sun.sun', 'elevation') %}
        {% if elevation is number %}
          {{ elevation | float(0) }}
        {% else %}
          {% set current_hour = now().hour %}
          {% set current_minute = now().minute %}
          {% set day_of_year = now().timetuple().tm_yday %}
          {% if current_hour >= 6 and current_hour <= 18 %}
            {# Seasonal adjustment: max sun elevation varies from ~28° (winter) to ~75° (summer) #}
            {% set summer_peak = 75 %}
            {% set winter_peak = 28 %}
            {% set seasonal_range = summer_peak - winter_peak %}
            {% set seasonal_offset = (day_of_year - 80) / 365 * 6.28 %}
            {% set seasonal_factor = winter_peak + seasonal_range * (1 + (seasonal_offset | sin)) / 2 %}
            
            {# Calculate elevation based on time from solar noon #}
            {% set hour_decimal = current_hour + (current_minute / 60.0) %}
            {% set hours_from_noon = (hour_decimal - 12) | abs %}
            {% if hours_from_noon <= 6 %}
              {% set elevation_factor = (1 - (hours_from_noon / 6) ** 2) %}
              {{ (seasonal_factor * elevation_factor) | round(1) }}
            {% else %}
              0
            {% endif %}
          {% else %}
            0
          {% endif %}
        {% endif %}
        {% endif %}
      
      # Base brightness calculation optimized to match outdoor light levels
      # Enhanced for 4x2x2 reptile enclosure with uniform light distribution
      base_brightness: >
        {% set elevation = sun_elevation | float(0) %}
        {% set current_hour = now().hour %}
        {% if current_hour >= 6 and current_hour <= 18 %}
          {# Scale brightness to match natural outdoor illumination levels #}
          {# Outdoor light ranges from ~0.1 lux (twilight) to ~100,000 lux (direct sun) #}
          {# Map this to 0-10 scale for LED controller #}
          {% if elevation > 60 %}
            {# High sun - maximum brightness #}
            10
          {% elif elevation > 40 %}
            {# Mid-day sun - high brightness #}
            {{ (8 + (elevation - 40) / 10) | round(0) | int }}
          {% elif elevation > 20 %}
            {# Morning/afternoon sun - moderate brightness #}
            {{ (5 + (elevation - 20) / 6.7) | round(0) | int }}
          {% elif elevation > 5 %}
            {# Low sun - dim but visible #}
            {{ (2 + (elevation - 5) / 5) | round(0) | int }}
          {% elif elevation > 0 %}
            {# Twilight - very dim #}
            {{ (elevation / 2.5) | round(0) | int }}
          {% else %}
            0
          {% endif %}
        {% else %}
          0
        {% endif %}

  # Step 3: Log current conditions for debugging
  - service: system_log.write
    data:
      message: >
        Circadian update: Sun={{ sun_elevation }}°, Base={{ base_brightness }}, 
        Weather={{ weather_condition }}, Time={{ now().strftime('%H:%M') }}
      level: debug
      logger: aquarium.circadian
    continue_on_error: true

  # Step 4: Check for lightning conditions and handle special effects
  - choose:
      # Lightning Effect Branch - Execute when storm conditions detected and lightning enabled
      - conditions:
          - condition: template
            value_template: "{{ weather_condition in ['lightning', 'lightning-rainy', 'thunderstorm'] }}"
          - condition: state
            entity_id: input_boolean.enable_aquarium_lightning
            state: 'on'
        sequence:
          # Log lightning effect activation
          - service: system_log.write
            data:
              message: "Storm detected with lightning enabled - triggering lightning effect"
              level: info
              logger: aquarium.circadian
          
          # Execute lightning effect script
          - service: script.turn_on
            target:
              entity_id: script.aquarium_lightning_effect
            continue_on_error: true    # Continue even if lightning effect fails

    # Default Branch - Normal lighting calculations
    default:
      # Step 5: Calculate target light levels based on sun elevation
      - variables:
          # White Channel - Primary illumination matching daylight
          # Scaled to provide uniform brightness in 4x2x2 enclosure
          target_white: >
            {% set current_hour = now().hour %}
            {% if sun_elevation > 10 %}
              {# Daylight hours - white provides primary illumination #}
              {{ [base_brightness | int, 1] | max }}
            {% elif sun_elevation > 0 %}
              {# Twilight - reduced white for natural color temperature #}
              {{ (base_brightness * 0.6) | round(0) | int }}
            {% else %}
              0
            {% endif %}
          
          # Red Channel - Warm light for sunrise/sunset, reduced during midday
          # Mimics natural color temperature changes throughout day
          target_red: >
            {% set current_hour = now().hour %}
            {% if sun_elevation < 20 and sun_elevation > 0 %}
              {# Low sun angle = warm light (sunrise/sunset) #}
              {{ [(base_brightness * (1 - sun_elevation/20) * 1.5) | round(0) | int, 10] | min }}
            {% elif current_hour >= 8 and current_hour <= 16 and base_brightness > 2 %}
              {# Midday - minimal red for balanced color temperature #}
              {{ [base_brightness * 0.15, 1] | max | round(0) | int }}
            {% else %}
              0
            {% endif %}
          
          # Green Channel - Natural balance, enhanced during active daylight hours
          # Provides natural spectrum balance for reptile health
          target_green: >
            {% if base_brightness > 1 %}
              {{ (target_white * 0.6 + target_red * 0.2 + base_brightness * 0.3) | round(0) | int }}
            {% else %}
              0
            {% endif %}
          
          # Blue Channel - Peaks during high sun, provides full spectrum lighting
          # Essential for natural circadian rhythm regulation
          target_blue: >
            {% set current_hour = now().hour %}
            {% if sun_elevation > 20 %}
              {# High sun - strong blue component #}
              {{ [(base_brightness * 0.8) | round(0) | int, 8] | min }}
            {% elif sun_elevation > 5 %}
              {# Moderate sun - balanced blue #}
              {{ [(base_brightness * 0.6) | round(0) | int, 6] | min }}
            {% elif current_hour >= 7 and current_hour <= 17 and base_brightness > 0 %}
              {# Daylight hours - minimal blue #}
              {{ [base_brightness * 0.3, 1] | max | round(0) | int }}
            {% else %}
              0
            {% endif %}

      # Step 6: Apply weather condition modifiers to match real outdoor lighting
      - variables:
          # Weather-Modified White Channel - Primary brightness adjustment
          modified_white: >
            {% set w = target_white %}
            {% if 'cloudy' in weather_condition %}
              {# Cloudy reduces light by ~30-50% #}
              {% set w = (w * 0.6) | round(0) | int %}
            {% elif 'rainy' in weather_condition %}
              {# Rain/storms reduce light by ~60-70% #}
              {% set w = (w * 0.4) | round(0) | int %}
            {% elif 'partly-cloudy' in weather_condition %}
              {# Partial clouds reduce light by ~15-20% #}
              {% set w = (w * 0.8) | round(0) | int %}
            {% endif %}
            {{ [w, 0] | max }}
          
          # Weather-Modified Red Channel - Warm light enhancement in overcast
          modified_red: >
            {% set r = target_red %}
            {% if 'cloudy' in weather_condition or 'rainy' in weather_condition %}
              {# Overcast enhances warm tones #}
              {% set r = (r * 1.2) | round(0) | int %}
            {% endif %}
            {{ [r, 10] | min }}
          
          # Weather-Modified Green Channel - Balanced adjustment
          modified_green: >
            {% set g = target_green %}
            {% if 'cloudy' in weather_condition %}
              {% set g = (g * 0.8) | round(0) | int %}
            {% elif 'rainy' in weather_condition %}
              {% set g = (g * 0.6) | round(0) | int %}
            {% elif 'partly-cloudy' in weather_condition %}
              {% set g = (g * 0.9) | round(0) | int %}
            {% endif %}
            {{ [g, 0] | max }}
          
          # Weather-Modified Blue Channel - Storm enhancement
          modified_blue: >
            {% set b = target_blue %}
            {% if 'rainy' in weather_condition %}
              {# Storms have cooler color temperature #}
              {% set b = (b * 1.3) | round(0) | int %}
            {% elif 'cloudy' in weather_condition %}
              {% set b = (b * 0.9) | round(0) | int %}
            {% elif 'partly-cloudy' in weather_condition %}
              {% set b = (b * 0.95) | round(0) | int %}
            {% endif %}
            {{ [b, 10] | min }}

      # Step 7: Ensure all values are within valid range (0-10) and log calculations
      - variables:
          final_white: "{{ [0, [10, modified_white] | min] | max }}"
          final_red: "{{ [0, [10, modified_red] | min] | max }}"
          final_green: "{{ [0, [10, modified_green] | min] | max }}"
          final_blue: "{{ [0, [10, modified_blue] | min] | max }}"

      # Step 8: Log calculated target values for debugging
      - service: system_log.write
        data:
          message: >
            Target levels: W={{ final_white }}, R={{ final_red }}, 
            G={{ final_green }}, B={{ final_blue }}
          level: debug
          logger: aquarium.circadian
        continue_on_error: true

      # Step 9: Execute state reconciliation with calculated targets
      - service: script.aquarium_reconcile_state
        target:
          entity_id: script.aquarium_reconcile_state
        data:
          target_w: "{{ final_white }}"
          target_r: "{{ final_red }}"
          target_g: "{{ final_green }}"
          target_b: "{{ final_blue }}"
        continue_on_error: true        # Continue even if reconciliation fails

# Error Recovery: All critical operations use 'continue_on_error' to ensure
# the automation doesn't get stuck on transient failures. System will retry
# on the next minute cycle.
