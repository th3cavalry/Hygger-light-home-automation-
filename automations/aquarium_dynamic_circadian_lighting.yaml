---
# Aquarium Dynamic Circadian Lighting Automation  
# The main "brain" of the lighting system - runs every minute to adjust lights
# Combines sun position, weather data, and user preferences for realistic lighting
#
# Features:
# - Solar elevation-based brightness calculation
# - Weather condition modifiers (cloudy, rainy, sunny)
# - Storm lightning effects (when enabled)
# - Comprehensive error handling and fallback logic
# - Detailed logging for debugging and monitoring

alias: "Aquarium Dynamic Circadian Lighting"
description: "Main lighting controller - adjusts aquarium lights every minute based on sun position and weather conditions"
mode: single                           # Prevent overlapping executions

# Trigger Configuration - Execute every minute for smooth transitions
trigger:
  - platform: time_pattern             # Time-based pattern trigger
    minutes: "/1"                      # Every minute (creates smooth lighting transitions)
    id: "circadian_update"             # Unique trigger identifier

# Conditions - Ensure required entities are available before running
condition:
  - condition: template
    value_template: >
      {{
        states('input_number.hygger_white_level') not in ['unknown', 'unavailable'] and
        states('input_number.hygger_red_level') not in ['unknown', 'unavailable'] and
        states('input_number.hygger_green_level') not in ['unknown', 'unavailable'] and
        states('input_number.hygger_blue_level') not in ['unknown', 'unavailable']
      }}

# Action Sequence - Complex lighting calculation and adjustment logic
action:
  # Step 1: Attempt to get fresh weather forecast data
  - service: weather.get_forecasts
    target:
      entity_id: weather.openweathermap # UPDATE: Change to your actual weather entity ID
    data:
      type: hourly                     # Get hourly forecast for detailed conditions
    response_variable: hourly_forecast # Store API response
    continue_on_error: true            # Don't fail if API is down

  # Step 2: Determine weather conditions with robust fallback logic
  - variables:
      # Simplified and more robust weather condition determination
      # Always defaults to 'sunny' to ensure lights work even without weather data
      weather_condition: >
        {% set default_condition = 'sunny' %}
        {% if hourly_forecast is defined and hourly_forecast is mapping and hourly_forecast | length > 0 %}
          {% set first_key = hourly_forecast.keys() | list | first %}
          {% if hourly_forecast[first_key] is defined and hourly_forecast[first_key].get('forecast', []) | length > 0 %}
            {{ hourly_forecast[first_key].forecast[0].get('condition', default_condition) }}
          {% else %}
            {{ default_condition }}
          {% endif %}
        {% elif states('input_text.aquarium_forecast_cache') not in ['unknown', 'unavailable', ''] and states('input_text.aquarium_forecast_cache') | length > 5 %}
          {% set cached = states('input_text.aquarium_forecast_cache') | from_json(default={'condition': default_condition}) %}
          {{ cached.get('condition', default_condition) }}
        {% else %}
          {{ default_condition }}
        {% endif %}
      
      # Sun elevation for lighting calculations with fallback
      sun_elevation: >
        {% set elevation = state_attr('sun.sun', 'elevation') %}
        {% if elevation is number %}
          {{ elevation | float(0) }}
        {% else %}
          {% set current_hour = now().hour %}
          {% if current_hour >= 6 and current_hour <= 18 %}
            {% if current_hour <= 12 %}
              {{ (current_hour - 6) * 15 }}
            {% else %}
              {{ 90 - ((current_hour - 12) * 15) }}
            {% endif %}
          {% else %}
            0
          {% endif %}
        {% endif %}
      
      # Base brightness calculation optimized for plant growth
      # Higher brightness levels throughout the day for healthy plant development
      base_brightness: >
        {% set elevation = sun_elevation | float(0) %}
        {% set current_hour = now().hour %}
        {% if current_hour >= 6 and current_hour <= 20 %}
          {% set calculated = (elevation / 6) | round(0) | int %}
          {{ [[calculated, 4] | max, 10] | min }}
        {% else %}
          0
        {% endif %}

  # Step 3: Log current conditions for debugging
  - service: system_log.write
    data:
      message: >
        Circadian update: Sun={{ sun_elevation }}Â°, Base={{ base_brightness }}, 
        Weather={{ weather_condition }}, Time={{ now().strftime('%H:%M') }}
      level: debug
      logger: aquarium.circadian
    continue_on_error: true

  # Step 4: Check for lightning conditions and handle special effects
  - choose:
      # Lightning Effect Branch - Execute when storm conditions detected and lightning enabled
      - conditions:
          - condition: template
            value_template: "{{ weather_condition in ['lightning', 'lightning-rainy', 'thunderstorm'] }}"
          - condition: state
            entity_id: input_boolean.enable_aquarium_lightning
            state: 'on'
        sequence:
          # Log lightning effect activation
          - service: system_log.write
            data:
              message: "Storm detected with lightning enabled - triggering lightning effect"
              level: info
              logger: aquarium.circadian
          
          # Execute lightning effect script
          - service: script.turn_on
            target:
              entity_id: script.aquarium_lightning_effect
            continue_on_error: true    # Continue even if lightning effect fails

    # Default Branch - Normal lighting calculations
    default:
      # Step 5: Calculate target light levels based on sun elevation
      - variables:
          # White Channel Calculation - Optimized for plant growth
          # Higher brightness during daylight hours for photosynthesis
          target_white: >
            {% set current_hour = now().hour %}
            {% if sun_elevation > 5 %}
              {{ [(base_brightness * (sun_elevation / 90) * 1.5) | round(0) | int, 10] | min }}
            {% elif current_hour >= 7 and current_hour <= 19 %}
              {{ [base_brightness | int, 4] | max }}
            {% else %}
              0
            {% endif %}
          
          # Red Channel Calculation - Enhanced for plant growth
          # Maintains red light during day for healthy plant development
          target_red: >
            {% set current_hour = now().hour %}
            {% if sun_elevation < 15 %}
              {{ [(base_brightness * (1 - (sun_elevation/15)) * 1.2) | round(0) | int, 10] | min }}
            {% elif current_hour >= 8 and current_hour <= 18 %}
              {{ [base_brightness * 0.2, 1] | max | round(0) | int }}
            {% else %}
              0
            {% endif %}
          
          # Green Channel Calculation - Enhanced balance for plant growth
          # Optimized blend for natural color temperature and plant health
          target_green: "{{ (target_white * 0.4 + target_red * 0.3 + base_brightness * 0.3) | round(0) | int }}"
          
          # Blue Channel Calculation - Enhanced for plant growth
          # Higher blue levels throughout day for optimal photosynthesis
          target_blue: >
            {% set current_hour = now().hour %}
            {% if sun_elevation > 5 %}
              {{ [(base_brightness * (sun_elevation / 90) * 1.0) | round(0) | int, 10] | min }}
            {% elif current_hour >= 7 and current_hour <= 19 %}
              {{ [base_brightness * 0.6, 2] | max | round(0) | int }}
            {% else %}
              0
            {% endif %}

      # Step 6: Apply weather condition modifiers
      - variables:
          # Weather-Modified White Channel
          modified_white: >
            {% set w = target_white %}
            {% if 'cloudy' in weather_condition %}
              {% set w = ([10, (w * 0.6 + 2)] | min) %}
            {% endif %}
            {% if 'rainy' in weather_condition %}
              {% set w = ([10, (w * 0.4 + 1)] | min) %}
            {% endif %}
            {{ w | round(0) | int }}
          
          # Weather-Modified Red Channel
          modified_red: >
            {% if 'cloudy' in weather_condition %}
              {{ (target_red * 0.5) | round(0) | int }}
            {% else %}
              {{ target_red }}
            {% endif %}
          
          # Weather-Modified Green Channel (recalculated with modified values)
          modified_green: "{{ (modified_white * 0.5 + modified_red * 0.5) | round(0) | int }}"
          
          # Weather-Modified Blue Channel
          modified_blue: >
            {% set b = target_blue %}
            {% if 'rainy' in weather_condition %}
              {% set b = ([10, (b * 0.7 + 2)] | min) %}
            {% endif %}
            {{ b | round(0) | int }}

      # Step 7: Ensure all values are within valid range (0-10) and log calculations
      - variables:
          final_white: "{{ [0, [10, modified_white] | min] | max }}"
          final_red: "{{ [0, [10, modified_red] | min] | max }}"
          final_green: "{{ [0, [10, modified_green] | min] | max }}"
          final_blue: "{{ [0, [10, modified_blue] | min] | max }}"

      # Step 8: Log calculated target values for debugging
      - service: system_log.write
        data:
          message: >
            Target levels: W={{ final_white }}, R={{ final_red }}, 
            G={{ final_green }}, B={{ final_blue }}
          level: debug
          logger: aquarium.circadian
        continue_on_error: true

      # Step 9: Execute state reconciliation with calculated targets
      - service: script.aquarium_reconcile_state
        target:
          entity_id: script.aquarium_reconcile_state
        data:
          target_w: "{{ final_white }}"
          target_r: "{{ final_red }}"
          target_g: "{{ final_green }}"
          target_b: "{{ final_blue }}"
        continue_on_error: true        # Continue even if reconciliation fails

# Error Recovery: All critical operations use 'continue_on_error' to ensure
# the automation doesn't get stuck on transient failures. System will retry
# on the next minute cycle.
